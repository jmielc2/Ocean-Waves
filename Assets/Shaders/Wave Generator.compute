#pragma kernel InitializeSpectrum

const float PI = 3.14159265358979323846;
const float G = 9.8;

RWTexture2D<float4> initial_spectrum;
uniform uint u_N;
uniform uint u_L;
uniform float2 u_wind_direction;
uniform float u_wind_speed;

// Huga Elias integer hash
float hash(uint n) {
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

// Box Muller transform
float2 UniformToGaussianDistribution(float u1, float u2) {
    float R = sqrt(-2.0f * log(u1));
    float theta = 2.0f * PI * u2;
    return float2(R * cos(theta), R * sin(theta));
}

float PhillipsSpectrum(float2 wavevector) {
    const float L = u_wind_speed * u_wind_speed / G;
    const float k = length(wavevector);
    const float inv_k = 1.0 / k;
    const float2 direction = wavevector / k;
    const float inv_k_times_L = 1.0 * inv_k / L;
    const float wind_dot_wavedirection = dot(u_wind_direction, direction);
    return 0.0081 * exp(-1.0 * inv_k_times_L * inv_k_times_L) * inv_k * inv_k * inv_k * inv_k * wind_dot_wavedirection * wind_dot_wavedirection;
}

float ShortWaveSuppressionFactor(float2 wavevector) {
    const float threshold = 0.1;
    const float k = length(wavevector);
    if (k < threshold)
    {
        return exp(-1.0 * k * k * threshold * threshold);
    }
    return 1.0;
}

[numthreads(8, 8, 1)]
void InitializeSpectrum(uint3 id : SV_DispatchThreadID) {
    const uint seed = id.y * u_N + id.x;
    float halfN = u_N / 2.0f;

    float deltaK = 2.0f * PI / u_L;
    float2 K = (id.xy - halfN) * deltaK;
    const float4 gaussians = float4(
        UniformToGaussianDistribution(hash(seed), hash(seed * 2)),
        UniformToGaussianDistribution(hash(seed * 3), hash(seed * 4))
    );
    const float spectrum = PhillipsSpectrum(K);
    float amplitude = sqrt(0.5 * spectrum) * 100.0;
    float val = K.x / 13.0;
    initial_spectrum[id.xy] = float4(val, 0, 0, 1);
}
